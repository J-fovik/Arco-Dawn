import {
  index_es_default
} from "./chunk-YLZPKDU4.js";
import {
  IconCheck,
  IconDelete,
  IconExclamation,
  IconFile,
  IconFileAudio,
  IconFileImage,
  IconFilePdf,
  IconFileVideo,
  IconPause,
  IconPlayArrowFill,
  IconUpload
} from "./chunk-KVY5E37C.js";
import {
  IconPlus
} from "./chunk-CGRU35D2.js";
import {
  IconHover
} from "./chunk-6AA63HMU.js";
import {
  IconEye
} from "./chunk-E4NAALYO.js";
import {
  IconExclamationCircleFill
} from "./chunk-UDFJIPY5.js";
import {
  Button
} from "./chunk-MFFEHUWQ.js";
import {
  useSize
} from "./chunk-RXLGYBCX.js";
import {
  useFormItem
} from "./chunk-4L6M45N7.js";
import {
  ImagePreviewGroup
} from "./chunk-FNX3K4T5.js";
import {
  Tooltip
} from "./chunk-7ZHYRO4L.js";
import {
  useI18n
} from "./chunk-4DXIYGG2.js";
import {
  IconImageClose
} from "./chunk-MRE7FA5I.js";
import {
  NOOP
} from "./chunk-XMRQ4BZ5.js";
import {
  _export_sfc
} from "./chunk-3DOTGVQM.js";
import {
  getComponentPrefix,
  getPrefixCls,
  isArray,
  isBoolean,
  isFunction,
  isObject,
  isPromise,
  setGlobalConfig
} from "./chunk-XID64W4O.js";
import {
  Fragment,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  guardReactiveProps,
  inject,
  mergeProps,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  toDisplayString,
  toRefs,
  watch,
  withCtx
} from "./chunk-RAKT47ZN.js";

// node_modules/@arco-design/web-vue/es/upload/utils.js
var getResponse = (xhr) => {
  const res = xhr.responseText || xhr.response;
  if (!res) {
    return void 0;
  }
  const contentType = xhr.getResponseHeader("Content-Type");
  if (contentType && contentType.includes("json")) {
    try {
      return JSON.parse(res);
    } catch {
      return res;
    }
  }
  return res;
};
var getProgressStatus = (status) => {
  switch (status) {
    case "done":
      return "success";
    case "error":
      return "danger";
    default:
      return "normal";
  }
};
var getValue = (obj, fileItem) => {
  if (isFunction(obj)) {
    return obj(fileItem);
  }
  return obj;
};
var uploadRequest = ({
  fileItem,
  action,
  name: originName,
  data: originData,
  headers = {},
  withCredentials = false,
  onProgress = NOOP,
  onSuccess = NOOP,
  onError = NOOP
}) => {
  const name = getValue(originName, fileItem) || "file";
  const data = getValue(originData, fileItem);
  const xhr = new XMLHttpRequest();
  if (withCredentials) {
    xhr.withCredentials = true;
  }
  xhr.upload.onprogress = (e) => {
    const percent = e.total > 0 ? index_es_default.round(e.loaded / e.total, 2) : 0;
    onProgress(percent, e);
  };
  xhr.onerror = function error(e) {
    onError(e);
  };
  xhr.onload = () => {
    if (xhr.status < 200 || xhr.status >= 300) {
      onError(getResponse(xhr));
      return;
    }
    onSuccess(getResponse(xhr));
  };
  const formData = new FormData();
  if (data) {
    for (const key of Object.keys(data)) {
      formData.append(key, data[key]);
    }
  }
  if (fileItem.file) {
    formData.append(name, fileItem.file);
  }
  xhr.open("post", action != null ? action : "", true);
  for (const key of Object.keys(headers)) {
    xhr.setRequestHeader(key, headers[key]);
  }
  xhr.send(formData);
  return {
    abort() {
      xhr.abort();
    }
  };
};
var isAcceptFile = (file, accept) => {
  if (accept && file) {
    const accepts = isArray(accept) ? accept : accept.split(",").map((x) => x.trim()).filter((x) => x);
    const fileExtension = (file.name.indexOf(".") > -1 ? `.${file.name.split(".").pop()}` : "").toLowerCase();
    return accepts.some((type) => {
      const typeText = type && type.toLowerCase();
      const fileType = (file.type || "").toLowerCase();
      const baseFileType = fileType.split("/")[0];
      if (typeText === fileType || `${baseFileType}${fileExtension.replace(".", "/")}` === typeText) {
        return true;
      }
      if (/^\*(\/\*)?$/.test(typeText)) {
        return true;
      }
      if (/\/\*/.test(typeText)) {
        return fileType.replace(/\/.*$/, "") === typeText.replace(/\/.*$/, "");
      }
      if (/\..*/.test(typeText)) {
        let suffixList = [typeText];
        if (typeText === ".jpg" || typeText === ".jpeg") {
          suffixList = [".jpg", ".jpeg"];
        }
        return suffixList.indexOf(fileExtension) > -1;
      }
      return false;
    });
  }
  return !!file;
};
var loopDirectory = (itemList, accept, callback) => {
  const files = [];
  let restFileCount = 0;
  const onFinish = () => {
    !restFileCount && callback(files);
  };
  const _loopDirectory = (item) => {
    restFileCount += 1;
    if (item == null ? void 0 : item.isFile) {
      item.file((file) => {
        restFileCount -= 1;
        if (isAcceptFile(file, accept)) {
          Object.defineProperty(file, "webkitRelativePath", {
            value: item.fullPath.replace(/^\//, "")
          });
          files.push(file);
        }
        onFinish();
      });
      return;
    }
    if (item == null ? void 0 : item.isDirectory) {
      const reader = item.createReader();
      let flag = false;
      const readEntries = () => {
        reader.readEntries((entries) => {
          if (!flag) {
            restFileCount -= 1;
            flag = true;
          }
          if (entries.length === 0) {
            onFinish();
          } else {
            readEntries();
            entries.forEach(_loopDirectory);
          }
        });
      };
      readEntries();
      return;
    }
    restFileCount -= 1;
    onFinish();
  };
  [].slice.call(itemList).forEach((item) => item.webkitGetAsEntry && _loopDirectory(item.webkitGetAsEntry()));
};
var isImage = (file) => {
  var _a;
  return (_a = file.type) == null ? void 0 : _a.includes("image");
};
var getFiles = (fileList, accept) => {
  if (!fileList) {
    return [];
  }
  const files = Array.from(fileList);
  if (accept) {
    return files.filter((file) => {
      return isAcceptFile(file, accept);
    });
  }
  return files;
};

// node_modules/@arco-design/web-vue/es/upload/upload-button.js
var UploadButton = defineComponent({
  name: "UploadButton",
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    directory: {
      type: Boolean,
      default: false
    },
    accept: String,
    listType: {
      type: String
    },
    tip: String,
    draggable: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    uploadFiles: {
      type: Function,
      required: true
    },
    hide: Boolean,
    onButtonClick: {
      type: Function
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("upload");
    const {
      t
    } = useI18n();
    const isDragging = ref(false);
    const inputRef = ref(null);
    const dropRef = ref(null);
    const dragEnterCount = ref(0);
    const setDragEnterCount = (type) => {
      if (type === "subtract") {
        dragEnterCount.value -= 1;
      } else if (type === "add") {
        dragEnterCount.value += 1;
      } else if (type === "reset") {
        dragEnterCount.value = 0;
      }
    };
    const handleClick = (e) => {
      if (props.disabled)
        return;
      if (isFunction(props.onButtonClick)) {
        const result = props.onButtonClick(e);
        if (isPromise(result)) {
          result.then((files) => {
            props.uploadFiles(getFiles(files));
          });
          return;
        }
      }
      if (inputRef.value) {
        inputRef.value.click();
      }
    };
    const handleInputChange = (e) => {
      const target = e.target;
      if (target.files) {
        props.uploadFiles(getFiles(target.files));
      }
      target.value = "";
    };
    const handleDrop = (e) => {
      var _a, _b;
      e.preventDefault();
      isDragging.value = false;
      setDragEnterCount("reset");
      if (props.disabled) {
        return;
      }
      if (props.directory && ((_a = e.dataTransfer) == null ? void 0 : _a.items)) {
        loopDirectory(e.dataTransfer.items, props.accept, (files) => {
          props.uploadFiles(files);
        });
      } else {
        const files = getFiles((_b = e.dataTransfer) == null ? void 0 : _b.files, props.accept);
        props.uploadFiles(props.multiple ? files : files.slice(0, 1));
      }
    };
    const handleDragLeave = (e) => {
      e.preventDefault();
      setDragEnterCount("subtract");
      if (dragEnterCount.value === 0) {
        isDragging.value = false;
        setDragEnterCount("reset");
      }
    };
    const handleDragOver = (e) => {
      e.preventDefault();
      if (!props.disabled && !isDragging.value) {
        isDragging.value = true;
      }
    };
    const renderButton = () => {
      if (slots.default) {
        return createVNode("span", null, [slots.default()]);
      }
      if (props.listType === "picture-card") {
        return createVNode("div", {
          "class": `${prefixCls}-picture-card`
        }, [createVNode("div", {
          "class": `${prefixCls}-picture-card-text`
        }, [createVNode(IconPlus, null, null)]), props.tip && createVNode("div", {
          "class": `${prefixCls}-tip`
        }, [props.tip])]);
      }
      if (props.draggable) {
        return createVNode("div", {
          "class": [`${prefixCls}-drag`, {
            [`${prefixCls}-drag-active`]: isDragging.value
          }]
        }, [createVNode("div", null, [createVNode(IconPlus, null, null)]), createVNode("div", {
          "class": `${prefixCls}-drag-text`
        }, [isDragging.value ? t("upload.dragHover") : t("upload.drag")]), props.tip && createVNode("div", {
          "class": `${prefixCls}-tip`
        }, [props.tip])]);
      }
      return createVNode(Button, {
        "type": "primary",
        "disabled": props.disabled
      }, {
        default: () => [t("upload.buttonText")],
        icon: () => createVNode(IconUpload, null, null)
      });
    };
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-type-picture-card`]: props.listType === "picture-card",
      [`${prefixCls}-draggable`]: props.draggable,
      [`${prefixCls}-disabled`]: props.disabled,
      [`${prefixCls}-hide`]: props.hide
    }]);
    return () => createVNode("span", {
      "ref": dropRef,
      "class": cls.value,
      "onClick": handleClick,
      "onDragenter": () => {
        setDragEnterCount("add");
      },
      "onDrop": handleDrop,
      "onDragover": handleDragOver,
      "onDragleave": handleDragLeave
    }, [createVNode("input", mergeProps({
      "ref": inputRef,
      "type": "file",
      "style": {
        display: "none"
      },
      "disabled": props.disabled,
      "accept": props.accept,
      "multiple": props.multiple
    }, props.directory ? {
      webkitdirectory: "webkitdirectory"
    } : {}, {
      "onChange": handleInputChange
    }), null), renderButton()]);
  }
});

// node_modules/@arco-design/web-vue/es/progress/line.js
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var DEFAULT_STROKE_WIDTH = {
  small: 3,
  medium: 4,
  large: 8
};
var getBackground = (color) => {
  if (!color) {
    return void 0;
  }
  if (isObject(color)) {
    const val = Object.keys(color).map((key) => `${color[key]} ${key}`).join(",");
    return {
      backgroundImage: `linear-gradient(to right, ${val})`
    };
  }
  return {
    backgroundColor: color
  };
};
var _sfc_main = defineComponent({
  name: "ProgressLine",
  components: {
    IconExclamationCircleFill
  },
  props: {
    percent: {
      type: Number,
      default: 0
    },
    animation: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: "medium"
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    width: {
      type: [Number, String],
      default: "100%"
    },
    color: {
      type: [String, Object],
      default: void 0
    },
    trackColor: String,
    formatText: {
      type: Function,
      default: void 0
    },
    status: {
      type: String
    },
    showText: Boolean
  },
  setup(props) {
    const prefixCls = getPrefixCls("progress-line");
    const strokeWidth = computed(() => {
      if (props.strokeWidth !== 4) {
        return props.strokeWidth;
      }
      return DEFAULT_STROKE_WIDTH[props.size];
    });
    const text = computed(() => `${index_es_default.times(props.percent, 100)}%`);
    const style = computed(() => ({
      width: props.width,
      height: `${strokeWidth.value}px`,
      backgroundColor: props.trackColor
    }));
    const barStyle = computed(() => __spreadValues({
      width: `${props.percent * 100}%`
    }, getBackground(props.color)));
    return {
      prefixCls,
      style,
      barStyle,
      text
    };
  }
});
var _hoisted_1 = ["aria-valuenow"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  return openBlock(), createElementBlock("div", {
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": _ctx.percent,
    class: normalizeClass(`${_ctx.prefixCls}-wrapper`)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.prefixCls),
      style: normalizeStyle(_ctx.style)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-bar-buffer`)
      }, null, 2),
      createBaseVNode("div", {
        class: normalizeClass([`${_ctx.prefixCls}-bar`]),
        style: normalizeStyle(_ctx.barStyle)
      }, null, 6)
    ], 6),
    _ctx.showText ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-text`)
    }, [
      renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
        createTextVNode(toDisplayString(_ctx.text) + " ", 1),
        _ctx.status === "danger" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 0 })) : createCommentVNode("v-if", true)
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1);
}
var ProgressLine = _export_sfc(_sfc_main, [["render", _sfc_render]]);

// node_modules/@arco-design/web-vue/es/progress/circle.js
var __ARCO_PROGRESS_SEED = 0;
var DEFAULT_WIDTH = {
  mini: 16,
  small: 48,
  medium: 64,
  large: 80
};
var DEFAULT_STROKE_WIDTH2 = {
  mini: 4,
  small: 3,
  medium: 4,
  large: 4
};
var _sfc_main2 = defineComponent({
  name: "ProgressCircle",
  components: {
    IconExclamation,
    IconCheck
  },
  props: {
    percent: {
      type: Number,
      default: 0
    },
    type: {
      type: String
    },
    size: {
      type: String,
      default: "medium"
    },
    strokeWidth: {
      type: Number
    },
    width: {
      type: Number,
      default: void 0
    },
    color: {
      type: [String, Object],
      default: void 0
    },
    trackColor: String,
    status: {
      type: String,
      default: void 0
    },
    showText: {
      type: Boolean,
      default: true
    },
    pathStrokeWidth: {
      type: Number
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("progress-circle");
    const isLinearGradient = isObject(props.color);
    const mergedWidth = computed(() => {
      var _a;
      return (_a = props.width) != null ? _a : DEFAULT_WIDTH[props.size];
    });
    const mergedStrokeWidth = computed(() => {
      var _a;
      return (_a = props.strokeWidth) != null ? _a : props.size === "mini" ? mergedWidth.value / 2 : DEFAULT_STROKE_WIDTH2[props.size];
    });
    const mergedPathStrokeWidth = computed(() => {
      var _a;
      return (_a = props.pathStrokeWidth) != null ? _a : props.size === "mini" ? mergedStrokeWidth.value : Math.max(2, mergedStrokeWidth.value - 2);
    });
    const radius = computed(() => (mergedWidth.value - mergedStrokeWidth.value) / 2);
    const perimeter = computed(() => Math.PI * 2 * radius.value);
    const center = computed(() => mergedWidth.value / 2);
    const linearGradientId = computed(() => {
      __ARCO_PROGRESS_SEED += 1;
      return `${prefixCls}-linear-gradient-${__ARCO_PROGRESS_SEED}`;
    });
    const text = computed(() => `${index_es_default.times(props.percent, 100)}%`);
    return {
      prefixCls,
      isLinearGradient,
      radius,
      text,
      perimeter,
      center,
      mergedWidth,
      mergedStrokeWidth,
      mergedPathStrokeWidth,
      linearGradientId
    };
  }
});
var _hoisted_12 = ["aria-valuenow"];
var _hoisted_2 = ["viewBox"];
var _hoisted_3 = { key: 0 };
var _hoisted_4 = ["id"];
var _hoisted_5 = ["offset", "stop-color"];
var _hoisted_6 = ["cx", "cy", "r", "stroke-width"];
var _hoisted_7 = ["cx", "cy", "r", "stroke-width"];
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_check = resolveComponent("icon-check");
  const _component_icon_exclamation = resolveComponent("icon-exclamation");
  return openBlock(), createElementBlock("div", {
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": _ctx.percent,
    class: normalizeClass(`${_ctx.prefixCls}-wrapper`),
    style: normalizeStyle({ width: `${_ctx.mergedWidth}px`, height: `${_ctx.mergedWidth}px` })
  }, [
    _ctx.type === "circle" && _ctx.size === "mini" && _ctx.status === "success" ? (openBlock(), createBlock(_component_icon_check, {
      key: 0,
      style: normalizeStyle({ fontSize: _ctx.mergedWidth - 2, color: _ctx.color })
    }, null, 8, ["style"])) : (openBlock(), createElementBlock("svg", {
      key: 1,
      viewBox: `0 0 ${_ctx.mergedWidth} ${_ctx.mergedWidth}`,
      class: normalizeClass(`${_ctx.prefixCls}-svg`)
    }, [
      _ctx.isLinearGradient ? (openBlock(), createElementBlock("defs", _hoisted_3, [
        createBaseVNode("linearGradient", {
          id: _ctx.linearGradientId,
          x1: "0",
          y1: "1",
          x2: "0",
          y2: "0"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(_ctx.color), (key) => {
            return openBlock(), createElementBlock("stop", {
              key,
              offset: key,
              "stop-color": _ctx.color[key]
            }, null, 8, _hoisted_5);
          }), 128))
        ], 8, _hoisted_4)
      ])) : createCommentVNode("v-if", true),
      createBaseVNode("circle", {
        class: normalizeClass(`${_ctx.prefixCls}-bg`),
        fill: "none",
        cx: _ctx.center,
        cy: _ctx.center,
        r: _ctx.radius,
        "stroke-width": _ctx.mergedPathStrokeWidth,
        style: normalizeStyle({
          stroke: _ctx.trackColor
        })
      }, null, 14, _hoisted_6),
      createBaseVNode("circle", {
        class: normalizeClass(`${_ctx.prefixCls}-bar`),
        fill: "none",
        cx: _ctx.center,
        cy: _ctx.center,
        r: _ctx.radius,
        "stroke-width": _ctx.mergedStrokeWidth,
        style: normalizeStyle({
          stroke: _ctx.isLinearGradient ? `url(#${_ctx.linearGradientId})` : _ctx.color,
          strokeDasharray: _ctx.perimeter,
          strokeDashoffset: (_ctx.percent >= 1 ? 0 : 1 - _ctx.percent) * _ctx.perimeter
        })
      }, null, 14, _hoisted_7)
    ], 10, _hoisted_2)),
    _ctx.showText && _ctx.size !== "mini" ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-text`)
    }, [
      renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
        _ctx.status === "danger" ? (openBlock(), createBlock(_component_icon_exclamation, { key: 0 })) : _ctx.status === "success" ? (openBlock(), createBlock(_component_icon_check, { key: 1 })) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          createTextVNode(toDisplayString(_ctx.text), 1)
        ], 2112))
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 14, _hoisted_12);
}
var ProgressCircle = _export_sfc(_sfc_main2, [["render", _sfc_render2]]);

// node_modules/@arco-design/web-vue/es/progress/steps.js
var _sfc_main3 = defineComponent({
  name: "ProgressSteps",
  components: {
    IconExclamationCircleFill
  },
  props: {
    steps: {
      type: Number,
      default: 0
    },
    percent: {
      type: Number,
      default: 0
    },
    size: {
      type: String
    },
    color: {
      type: [String, Object],
      default: void 0
    },
    trackColor: String,
    strokeWidth: {
      type: Number
    },
    status: {
      type: String,
      default: void 0
    },
    showText: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("progress-steps");
    const mergedStrokeWidth = computed(() => {
      var _a;
      return ((_a = props.strokeWidth) != null ? _a : props.size === "small") ? 8 : 4;
    });
    const stepList = computed(() => [...Array(props.steps)].map((_, index) => {
      return props.percent > 0 && props.percent > 1 / props.steps * index;
    }));
    const text = computed(() => `${index_es_default.times(props.percent, 100)}%`);
    return {
      prefixCls,
      stepList,
      mergedStrokeWidth,
      text
    };
  }
});
var _hoisted_13 = ["aria-valuenow"];
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  return openBlock(), createElementBlock("div", {
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": _ctx.percent,
    class: normalizeClass(`${_ctx.prefixCls}-wrapper`)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.prefixCls),
      style: normalizeStyle({ height: `${_ctx.mergedStrokeWidth}px` })
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.stepList, (active, index) => {
        return openBlock(), createElementBlock("div", {
          key: index,
          class: normalizeClass([
            `${_ctx.prefixCls}-item`,
            {
              [`${_ctx.prefixCls}-item-active`]: active
            }
          ]),
          style: normalizeStyle({
            backgroundColor: active ? _ctx.color : _ctx.trackColor
          })
        }, null, 6);
      }), 128))
    ], 6),
    _ctx.showText ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-text`)
    }, [
      renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
        createTextVNode(toDisplayString(_ctx.text) + " ", 1),
        _ctx.status === "danger" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 0 })) : createCommentVNode("v-if", true)
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_13);
}
var ProgressSteps = _export_sfc(_sfc_main3, [["render", _sfc_render3]]);

// node_modules/@arco-design/web-vue/es/progress/progress.js
var _sfc_main4 = defineComponent({
  name: "Progress",
  components: {
    ProgressLine,
    ProgressCircle,
    ProgressSteps
  },
  props: {
    type: {
      type: String,
      default: "line"
    },
    size: {
      type: String
    },
    percent: {
      type: Number,
      default: 0
    },
    steps: {
      type: Number,
      default: 0
    },
    animation: {
      type: Boolean,
      default: false
    },
    strokeWidth: {
      type: Number
    },
    width: {
      type: [Number, String]
    },
    color: {
      type: [String, Object]
    },
    trackColor: String,
    bufferColor: {
      type: [String, Object]
    },
    showText: {
      type: Boolean,
      default: true
    },
    status: {
      type: String
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("progress");
    const { size } = toRefs(props);
    const type = computed(() => props.steps > 0 ? "steps" : props.type);
    const computedStatus = computed(() => {
      return props.status || (props.percent >= 1 ? "success" : "normal");
    });
    const { mergedSize } = useSize(size);
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-type-${type.value}`,
      `${prefixCls}-size-${mergedSize.value}`,
      `${prefixCls}-status-${computedStatus.value}`
    ]);
    return {
      cls,
      computedStatus,
      mergedSize
    };
  }
});
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_progress_steps = resolveComponent("progress-steps");
  const _component_progress_line = resolveComponent("progress-line");
  const _component_progress_circle = resolveComponent("progress-circle");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    _ctx.steps > 0 ? (openBlock(), createBlock(_component_progress_steps, {
      key: 0,
      "stroke-width": _ctx.strokeWidth,
      percent: _ctx.percent,
      color: _ctx.color,
      "track-color": _ctx.trackColor,
      width: _ctx.width,
      steps: _ctx.steps,
      size: _ctx.mergedSize,
      "show-text": _ctx.showText
    }, createSlots({ _: 2 }, [
      _ctx.$slots.text ? {
        name: "text",
        fn: withCtx((scope) => [
          renderSlot(_ctx.$slots, "text", normalizeProps(guardReactiveProps(scope)))
        ])
      } : void 0
    ]), 1032, ["stroke-width", "percent", "color", "track-color", "width", "steps", "size", "show-text"])) : _ctx.type === "line" && _ctx.mergedSize !== "mini" ? (openBlock(), createBlock(_component_progress_line, {
      key: 1,
      "stroke-width": _ctx.strokeWidth,
      animation: _ctx.animation,
      percent: _ctx.percent,
      color: _ctx.color,
      "track-color": _ctx.trackColor,
      size: _ctx.mergedSize,
      "buffer-color": _ctx.bufferColor,
      width: _ctx.width,
      "show-text": _ctx.showText,
      status: _ctx.computedStatus
    }, createSlots({ _: 2 }, [
      _ctx.$slots.text ? {
        name: "text",
        fn: withCtx((scope) => [
          renderSlot(_ctx.$slots, "text", normalizeProps(guardReactiveProps(scope)))
        ])
      } : void 0
    ]), 1032, ["stroke-width", "animation", "percent", "color", "track-color", "size", "buffer-color", "width", "show-text", "status"])) : (openBlock(), createBlock(_component_progress_circle, {
      key: 2,
      type: _ctx.type,
      "stroke-width": _ctx.type === "line" ? _ctx.strokeWidth || 4 : _ctx.strokeWidth,
      "path-stroke-width": _ctx.type === "line" ? _ctx.strokeWidth || 4 : _ctx.strokeWidth,
      width: _ctx.width,
      percent: _ctx.percent,
      color: _ctx.color,
      "track-color": _ctx.trackColor,
      size: _ctx.mergedSize,
      "show-text": _ctx.showText,
      status: _ctx.computedStatus
    }, createSlots({ _: 2 }, [
      _ctx.$slots.text ? {
        name: "text",
        fn: withCtx((scope) => [
          renderSlot(_ctx.$slots, "text", normalizeProps(guardReactiveProps(scope)))
        ])
      } : void 0
    ]), 1032, ["type", "stroke-width", "path-stroke-width", "width", "percent", "color", "track-color", "size", "show-text", "status"]))
  ], 2);
}
var _Progress = _export_sfc(_sfc_main4, [["render", _sfc_render4]]);

// node_modules/@arco-design/web-vue/es/progress/index.js
var Progress = Object.assign(_Progress, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Progress.name, _Progress);
  }
});

// node_modules/@arco-design/web-vue/es/upload/context.js
var uploadInjectionKey = Symbol("ArcoUpload");

// node_modules/@arco-design/web-vue/es/upload/upload-progress.js
var UploadProgress = defineComponent({
  name: "UploadProgress",
  props: {
    file: {
      type: Object,
      required: true
    },
    listType: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("upload-progress");
    const {
      t
    } = useI18n();
    const uploadCtx = inject(uploadInjectionKey, void 0);
    const renderIcon = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (props.file.status === "error") {
        return createVNode("span", {
          "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-upload`],
          "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
        }, [(uploadCtx == null ? void 0 : uploadCtx.showRetryButton) && ((_e = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots)["retry-icon"]) == null ? void 0 : _b.call(_a)) != null ? _e : (_d = (_c = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c.retryIcon) == null ? void 0 : _d.call(_c)) || props.listType === "picture-card" ? createVNode(IconUpload, null, null) : t("upload.retry")]);
      }
      if (props.file.status === "done") {
        return createVNode("span", {
          "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-success`]
        }, [(_k = (_j = (_g = uploadCtx == null ? void 0 : (_f = uploadCtx.slots)["success-icon"]) == null ? void 0 : _g.call(_f)) != null ? _j : (_i = (_h = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _h.successIcon) == null ? void 0 : _i.call(_h)) != null ? _k : createVNode(IconCheck, null, null)]);
      }
      if (props.file.status === "init") {
        return createVNode(Tooltip, {
          "content": t("upload.start")
        }, {
          default: () => {
            var _a2, _b2, _c2, _d2, _e2, _f2;
            return [createVNode("span", {
              "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-start`],
              "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
            }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["start-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.startIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : createVNode(IconPlayArrowFill, null, null)])];
          }
        });
      }
      return (uploadCtx == null ? void 0 : uploadCtx.showCancelButton) && createVNode(Tooltip, {
        "content": t("upload.cancel")
      }, {
        default: () => {
          var _a2, _b2, _c2, _d2, _e2, _f2;
          return [createVNode("span", {
            "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-cancel`],
            "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onAbort(props.file)
          }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["cancel-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.cancelIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : createVNode(IconPause, null, null)])];
        }
      });
    };
    const renderProgress = () => {
      var _a;
      if (["init", "uploading"].includes((_a = props.file.status) != null ? _a : "")) {
        const status = getProgressStatus(props.file.status);
        return createVNode(Progress, {
          "type": "circle",
          "size": "mini",
          "showText": false,
          "status": status,
          "percent": props.file.percent
        }, null);
      }
      return null;
    };
    return () => createVNode("span", {
      "class": prefixCls
    }, [renderProgress(), renderIcon()]);
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload-list-item.js
var UploadListItem = defineComponent({
  name: "UploadListItem",
  props: {
    file: {
      type: Object,
      required: true
    },
    listType: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("upload-list");
    const itemCls = `${prefixCls}-item`;
    const {
      t
    } = useI18n();
    const uploadCtx = inject(uploadInjectionKey, void 0);
    const renderFileIcon = () => {
      var _a, _b;
      let type = "";
      if (props.file.file && props.file.file.type) {
        type = props.file.file.type;
      } else {
        const extension = (_b = (_a = props.file.name) == null ? void 0 : _a.split(".")[1]) != null ? _b : "";
        if (["png", "jpg", "jpeg", "bmp", "gif", "webp"].includes(extension)) {
          type = "image";
        } else if (["mp4", "m2v", "mkv", "m4v", "mov"].includes(extension)) {
          type = "video";
        } else if (["mp3", "wav", "wmv", "m4a", "acc", "flac"].includes(extension)) {
          type = "audio";
        }
      }
      if (type.includes("image")) {
        return createVNode(IconFileImage, null, null);
      }
      if (type.includes("pdf")) {
        return createVNode(IconFilePdf, null, null);
      }
      if (type.includes("audio")) {
        return createVNode(IconFileAudio, null, null);
      }
      if (type.includes("video")) {
        return createVNode(IconFileVideo, null, null);
      }
      return createVNode(IconFile, null, null);
    };
    return () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w;
      return createVNode("div", {
        "class": [itemCls, `${itemCls}-${props.file.status}`]
      }, [createVNode("div", {
        "class": `${itemCls}-content`
      }, [(uploadCtx == null ? void 0 : uploadCtx.listType) === "picture" && createVNode("span", {
        "class": `${itemCls}-thumbnail`
      }, [(_c = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots).image) == null ? void 0 : _b.call(_a, {
        fileItem: props.file
      })) != null ? _c : createVNode("img", mergeProps({
        "src": props.file.url,
        "alt": props.file.name
      }, (uploadCtx == null ? void 0 : uploadCtx.imageLoading) ? {
        loading: uploadCtx.imageLoading
      } : void 0), null)]), createVNode("div", {
        "class": `${itemCls}-name`
      }, [(uploadCtx == null ? void 0 : uploadCtx.listType) === "text" && createVNode("span", {
        "class": `${itemCls}-file-icon`
      }, [(_i = (_h = (_e = uploadCtx == null ? void 0 : (_d = uploadCtx.slots)["file-icon"]) == null ? void 0 : _e.call(_d, {
        fileItem: props.file
      })) != null ? _h : (_g = (_f = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _f.fileIcon) == null ? void 0 : _g.call(_f, props.file)) != null ? _i : renderFileIcon()]), (uploadCtx == null ? void 0 : uploadCtx.showLink) && props.file.url ? createVNode("a", mergeProps({
        "class": `${itemCls}-name-link`,
        "target": "_blank",
        "href": props.file.url
      }, (uploadCtx == null ? void 0 : uploadCtx.download) ? {
        download: props.file.name
      } : void 0), [(_o = (_n = (_k = uploadCtx == null ? void 0 : (_j = uploadCtx.slots)["file-name"]) == null ? void 0 : _k.call(_j, {
        fileItem: props.file
      })) != null ? _n : (_m = (_l = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _l.fileName) == null ? void 0 : _m.call(_l, props.file)) != null ? _o : props.file.name]) : createVNode("span", {
        "class": `${itemCls}-name-text`,
        "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onPreview(props.file)
      }, [(_u = (_t = (_q = uploadCtx == null ? void 0 : (_p = uploadCtx.slots)["file-name"]) == null ? void 0 : _q.call(_p, {
        fileItem: props.file
      })) != null ? _t : (_s = (_r = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _r.fileName) == null ? void 0 : _s.call(_r, props.file)) != null ? _u : props.file.name]), props.file.status === "error" && createVNode(Tooltip, {
        "content": t("upload.error")
      }, {
        default: () => {
          var _a2, _b2, _c2, _d2, _e2, _f2;
          return [createVNode("span", {
            "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-error`]
          }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["error-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.errorIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : createVNode(IconExclamationCircleFill, null, null)])];
        }
      })]), createVNode(UploadProgress, {
        "file": props.file,
        "listType": props.listType
      }, null)]), (uploadCtx == null ? void 0 : uploadCtx.showRemoveButton) && createVNode("span", {
        "class": `${itemCls}-operation`
      }, [createVNode(IconHover, {
        "onClick": () => {
          var _a2;
          return (_a2 = uploadCtx == null ? void 0 : uploadCtx.onRemove) == null ? void 0 : _a2.call(uploadCtx, props.file);
        }
      }, {
        default: () => {
          var _a2, _b2, _c2, _d2, _e2, _f2;
          return [createVNode("span", {
            "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-remove`]
          }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["remove-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.removeIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : createVNode(IconDelete, null, null)])];
        }
      })]), (_w = uploadCtx == null ? void 0 : (_v = uploadCtx.slots)["extra-button"]) == null ? void 0 : _w.call(_v, {
        fileItem: props.file
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload-picture-item.js
var UploadPictureItem = defineComponent({
  name: "UploadPictureItem",
  props: {
    file: {
      type: Object,
      required: true
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("upload-list");
    const itemCls = `${prefixCls}-picture`;
    const cls = computed(() => [itemCls, {
      [`${itemCls}-status-error`]: props.file.status === "error"
    }]);
    const uploadCtx = inject(uploadInjectionKey, void 0);
    const renderCard = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C;
      if (props.file.status === "uploading") {
        return createVNode(UploadProgress, {
          "file": props.file,
          "listType": "picture-card"
        }, null);
      }
      return createVNode(Fragment, null, [(_c = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots).image) == null ? void 0 : _b.call(_a, {
        fileItem: props.file
      })) != null ? _c : createVNode("img", mergeProps({
        "src": props.file.url,
        "alt": props.file.name
      }, (uploadCtx == null ? void 0 : uploadCtx.imageLoading) ? {
        loading: uploadCtx.imageLoading
      } : void 0), null), createVNode("div", {
        "class": `${itemCls}-mask`
      }, [props.file.status === "error" && (uploadCtx == null ? void 0 : uploadCtx.showCancelButton) && createVNode("div", {
        "class": `${itemCls}-error-tip`
      }, [createVNode("span", {
        "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-error`]
      }, [(_i = (_h = (_e = uploadCtx == null ? void 0 : (_d = uploadCtx.slots)["error-icon"]) == null ? void 0 : _e.call(_d)) != null ? _h : (_g = (_f = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _f.errorIcon) == null ? void 0 : _g.call(_f)) != null ? _i : createVNode(IconImageClose, null, null)])]), createVNode("div", {
        "class": `${itemCls}-operation`
      }, [props.file.status !== "error" && (uploadCtx == null ? void 0 : uploadCtx.showPreviewButton) && createVNode("span", {
        "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-preview`],
        "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onPreview(props.file)
      }, [(_o = (_n = (_k = uploadCtx == null ? void 0 : (_j = uploadCtx.slots)["preview-icon"]) == null ? void 0 : _k.call(_j)) != null ? _n : (_m = (_l = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _l.previewIcon) == null ? void 0 : _m.call(_l)) != null ? _o : createVNode(IconEye, null, null)]), ["init", "error"].includes(props.file.status) && (uploadCtx == null ? void 0 : uploadCtx.showRetryButton) && createVNode("span", {
        "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-upload`],
        "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
      }, [(_u = (_t = (_q = uploadCtx == null ? void 0 : (_p = uploadCtx.slots)["retry-icon"]) == null ? void 0 : _q.call(_p)) != null ? _t : (_s = (_r = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _r.retryIcon) == null ? void 0 : _s.call(_r)) != null ? _u : createVNode(IconUpload, null, null)]), !(uploadCtx == null ? void 0 : uploadCtx.disabled) && (uploadCtx == null ? void 0 : uploadCtx.showRemoveButton) && createVNode("span", {
        "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-remove`],
        "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onRemove(props.file)
      }, [(_A = (_z = (_w = uploadCtx == null ? void 0 : (_v = uploadCtx.slots)["remove-icon"]) == null ? void 0 : _w.call(_v)) != null ? _z : (_y = (_x = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _x.removeIcon) == null ? void 0 : _y.call(_x)) != null ? _A : createVNode(IconDelete, null, null)]), (_C = uploadCtx == null ? void 0 : (_B = uploadCtx.slots)["extra-button"]) == null ? void 0 : _C.call(_B, props.file)])])]);
    };
    return () => createVNode("span", {
      "class": cls.value
    }, [renderCard()]);
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload-list.js
var UploadList = defineComponent({
  name: "UploadList",
  components: {
    UploadListItem,
    UploadPictureItem
  },
  props: {
    fileList: {
      type: Array,
      required: true
    },
    listType: {
      type: String,
      required: true
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("upload");
    const cls = computed(() => [`${prefixCls}-list`, `${prefixCls}-list-type-${props.listType}`]);
    const renderItem = (fileItem, index) => {
      if (isFunction(slots["upload-item"])) {
        return slots["upload-item"]({
          fileItem,
          index
        });
      }
      if (props.listType === "picture-card") {
        return createVNode(UploadPictureItem, {
          "file": fileItem,
          "key": `item-${index}`
        }, null);
      }
      return createVNode(UploadListItem, {
        "file": fileItem,
        "listType": props.listType,
        "key": `item-${index}`
      }, null);
    };
    return () => createVNode(TransitionGroup, {
      "tag": "div",
      "class": cls.value
    }, {
      default: () => {
        var _a;
        return [...props.fileList.map((item, index) => renderItem(item, index)), props.listType === "picture-card" && ((_a = slots["upload-button"]) == null ? void 0 : _a.call(slots))];
      }
    });
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var _Upload = defineComponent({
  name: "Upload",
  props: {
    fileList: {
      type: Array,
      default: void 0
    },
    defaultFileList: {
      type: Array,
      default: () => []
    },
    accept: String,
    action: String,
    disabled: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    directory: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    tip: String,
    headers: {
      type: Object
    },
    data: {
      type: [Object, Function]
    },
    name: {
      type: [String, Function]
    },
    withCredentials: {
      type: Boolean,
      default: false
    },
    customRequest: {
      type: Function
    },
    limit: {
      type: Number,
      default: 0
    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    showFileList: {
      type: Boolean,
      default: true
    },
    showRemoveButton: {
      type: Boolean,
      default: true
    },
    showRetryButton: {
      type: Boolean,
      default: true
    },
    showCancelButton: {
      type: Boolean,
      default: true
    },
    showUploadButton: {
      type: [Boolean, Object],
      default: true
    },
    showPreviewButton: {
      type: Boolean,
      default: true
    },
    download: {
      type: Boolean,
      default: false
    },
    showLink: {
      type: Boolean,
      default: true
    },
    imageLoading: {
      type: String
    },
    listType: {
      type: String,
      default: "text"
    },
    responseUrlKey: {
      type: [String, Function]
    },
    customIcon: {
      type: Object
    },
    imagePreview: {
      type: Boolean,
      default: false
    },
    onBeforeUpload: {
      type: Function
    },
    onBeforeRemove: {
      type: Function
    },
    onButtonClick: {
      type: Function
    }
  },
  emits: {
    "update:fileList": (fileList) => true,
    "exceedLimit": (fileList, files) => true,
    "change": (fileList, fileItem) => true,
    "progress": (fileItem, ev) => true,
    "preview": (fileItem) => true,
    "success": (fileItem) => true,
    "error": (fileItem) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      fileList,
      disabled,
      listType,
      customIcon,
      showRetryButton,
      showCancelButton,
      showRemoveButton,
      showPreviewButton,
      imageLoading,
      download,
      showLink
    } = toRefs(props);
    const prefixCls = getPrefixCls("upload");
    const {
      mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled
    });
    const _fileList = ref([]);
    const fileMap = /* @__PURE__ */ new Map();
    const requestMap = /* @__PURE__ */ new Map();
    const isMax = computed(() => {
      return props.limit > 0 && _fileList.value.length >= props.limit;
    });
    const checkFileList = (fileList2) => {
      fileMap.clear();
      const newFileList = fileList2 == null ? void 0 : fileList2.map((data, index) => {
        var _a, _b, _c;
        const status = (_a = data.status) != null ? _a : "done";
        const fileItem = reactive(__spreadProps(__spreadValues2({}, data), {
          uid: (_b = data.uid) != null ? _b : `${Date.now()}${index}`,
          status,
          percent: (_c = data.percent) != null ? _c : ["error", "init"].indexOf(status) > -1 ? 0 : 1
        }));
        fileMap.set(fileItem.uid, fileItem);
        return fileItem;
      });
      _fileList.value = newFileList != null ? newFileList : [];
    };
    checkFileList(props.defaultFileList);
    watch(fileList, (fileList2) => {
      if (fileList2) {
        checkFileList(fileList2);
      }
    }, {
      immediate: true,
      deep: true
    });
    const updateFileList = (file) => {
      var _a, _b;
      emit("update:fileList", _fileList.value);
      emit("change", _fileList.value, file);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
    };
    const updateFile = (id, file) => {
      for (const item of _fileList.value) {
        if (item.uid === id) {
          item.file = file;
          updateFileList(item);
          break;
        }
      }
    };
    const uploadFile = (fileItem) => {
      const handleProgress = (percent, event) => {
        const file = fileMap.get(fileItem.uid);
        if (file) {
          file.status = "uploading";
          file.percent = percent;
          emit("progress", file, event);
          updateFileList(file);
        }
      };
      const handleSuccess = (response) => {
        const file = fileMap.get(fileItem.uid);
        if (file) {
          file.status = "done";
          file.percent = 1;
          file.response = response;
          if (props.responseUrlKey) {
            if (isFunction(props.responseUrlKey)) {
              file.url = props.responseUrlKey(file);
            } else if (response[props.responseUrlKey]) {
              file.url = response[props.responseUrlKey];
            }
          }
          requestMap.delete(file.uid);
          emit("success", file);
          updateFileList(file);
        }
      };
      const handleError = (response) => {
        const file = fileMap.get(fileItem.uid);
        if (file) {
          file.status = "error";
          file.percent = 0;
          file.response = response;
          requestMap.delete(file.uid);
          emit("error", file);
          updateFileList(file);
        }
      };
      const option = {
        fileItem,
        action: props.action,
        name: props.name,
        data: props.data,
        headers: props.headers,
        withCredentials: props.withCredentials,
        onProgress: handleProgress,
        onSuccess: handleSuccess,
        onError: handleError
      };
      fileItem.status = "uploading";
      fileItem.percent = 0;
      const request = isFunction(props.customRequest) ? props.customRequest(option) : uploadRequest(option);
      requestMap.set(fileItem.uid, request);
      updateFileList(fileItem);
    };
    const abort = (fileItem) => {
      var _a;
      const req = requestMap.get(fileItem.uid);
      if (req) {
        (_a = req.abort) == null ? void 0 : _a.call(req);
        requestMap.delete(fileItem.uid);
        const file = fileMap.get(fileItem.uid);
        if (file) {
          file.status = "error";
          file.percent = 0;
          updateFileList(file);
        }
      }
    };
    const submit = (fileItem) => {
      if (fileItem) {
        const file = fileMap.get(fileItem.uid);
        if (file) {
          uploadFile(file);
        }
      } else {
        for (const item of _fileList.value) {
          if (item.status === "init") {
            uploadFile(item);
          }
        }
      }
    };
    const initUpload = async (file, index) => {
      const uid = `${Date.now()}-${index}`;
      const dataURL = isImage(file) ? URL.createObjectURL(file) : void 0;
      const fileItem = reactive({
        uid,
        file,
        url: dataURL,
        name: file.name,
        status: "init",
        percent: 0
      });
      fileMap.set(uid, fileItem);
      _fileList.value = [..._fileList.value, fileItem];
      updateFileList(fileItem);
      if (props.autoUpload) {
        uploadFile(fileItem);
      }
    };
    const uploadFiles = (files) => {
      if (props.limit > 0 && _fileList.value.length + files.length > props.limit) {
        emit("exceedLimit", _fileList.value, files);
        return;
      }
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (isFunction(props.onBeforeUpload)) {
          Promise.resolve(props.onBeforeUpload(file)).then((result) => {
            if (result) {
              initUpload(isBoolean(result) ? file : result, i);
            }
          }).catch((err) => {
            console.error(err);
          });
        } else {
          initUpload(file, i);
        }
      }
    };
    const removeFile = (fileItem) => {
      _fileList.value = _fileList.value.filter((item) => {
        return item.uid !== fileItem.uid;
      });
      updateFileList(fileItem);
    };
    const handleRemove = (fileItem) => {
      if (isFunction(props.onBeforeRemove)) {
        Promise.resolve(props.onBeforeRemove(fileItem)).then((result) => {
          if (result) {
            removeFile(fileItem);
          }
        }).catch((err) => {
          console.error(err);
        });
      } else {
        removeFile(fileItem);
      }
    };
    const handlePreview = (fileItem) => {
      if (props.imagePreview && fileItem.url) {
        const current = imageList.value.indexOf(fileItem.url);
        if (current > -1) {
          imagePreviewCurrent.value = current;
          imagePreviewVisible.value = true;
        }
      }
      emit("preview", fileItem);
    };
    provide(uploadInjectionKey, reactive({
      disabled: mergedDisabled,
      listType,
      iconCls: `${prefixCls}-icon`,
      showRemoveButton,
      showRetryButton,
      showCancelButton,
      showPreviewButton,
      showLink,
      imageLoading,
      download,
      customIcon,
      slots,
      onUpload: uploadFile,
      onAbort: abort,
      onRemove: handleRemove,
      onPreview: handlePreview
    }));
    const mergedAccept = computed(() => {
      if (props.accept) {
        return props.accept;
      }
      if (props.listType === "picture" || props.listType === "picture-card") {
        return "image/*";
      }
      return void 0;
    });
    const renderButton = () => {
      const button = createVNode(UploadButton, {
        "key": "arco-upload-button",
        "disabled": mergedDisabled.value,
        "draggable": props.draggable,
        "listType": props.listType,
        "uploadFiles": uploadFiles,
        "multiple": props.multiple,
        "directory": props.directory,
        "tip": props.tip,
        "hide": !props.showUploadButton || isMax.value && !(isObject(props.showUploadButton) && props.showUploadButton.showOnExceedLimit),
        "accept": mergedAccept.value,
        "onButtonClick": props.onButtonClick
      }, {
        default: slots["upload-button"]
      });
      if (props.tip && props.listType !== "picture-card" && !props.draggable) {
        return createVNode("span", null, [button, createVNode("div", {
          "class": `${prefixCls}-tip`
        }, [props.tip])]);
      }
      return button;
    };
    const imagePreviewVisible = ref(false);
    const imagePreviewCurrent = ref(0);
    const handleImagePreviewChange = (current) => {
      imagePreviewCurrent.value = current;
    };
    const handleImagePreviewVisibleChange = (visible) => {
      imagePreviewVisible.value = visible;
    };
    const imageList = computed(() => _fileList.value.filter((item) => Boolean(item.url)).map((item) => item.url));
    const render = () => {
      if (!props.showFileList) {
        return props.showUploadButton && renderButton();
      }
      return createVNode("div", {
        "class": [`${prefixCls}-wrapper`, `${prefixCls}-wrapper-type-${props.listType}`]
      }, [props.imagePreview && imageList.value.length > 0 && createVNode(ImagePreviewGroup, {
        "srcList": imageList.value,
        "visible": imagePreviewVisible.value,
        "current": imagePreviewCurrent.value,
        "onChange": handleImagePreviewChange,
        "onVisibleChange": handleImagePreviewVisibleChange
      }, null), props.listType !== "picture-card" && props.showUploadButton && renderButton(), createVNode(UploadList, {
        "fileList": _fileList.value,
        "listType": props.listType
      }, {
        "upload-button": renderButton,
        "upload-item": slots["upload-item"]
      })]);
    };
    return {
      prefixCls,
      render,
      innerSubmit: submit,
      innerAbort: abort,
      innerUpdateFile: updateFile,
      innerUpload: uploadFiles
    };
  },
  methods: {
    submit(fileItem) {
      return this.innerSubmit(fileItem);
    },
    abort(fileItem) {
      return this.innerAbort(fileItem);
    },
    updateFile(id, file) {
      return this.innerUpdateFile(id, file);
    },
    upload(files) {
      return this.innerUpload(files);
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/upload/index.js
var Upload = Object.assign(_Upload, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Upload.name, _Upload);
  }
});

export {
  Progress,
  Upload
};
//# sourceMappingURL=chunk-BBNVBCUQ.js.map
