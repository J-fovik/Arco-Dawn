import {
  InputNumber
} from "./chunk-GUSPXRKZ.js";
import {
  index_es_default
} from "./chunk-YLZPKDU4.js";
import {
  useFormItem
} from "./chunk-4L6M45N7.js";
import {
  Tooltip
} from "./chunk-7ZHYRO4L.js";
import {
  off,
  on
} from "./chunk-XMRQ4BZ5.js";
import {
  _export_sfc
} from "./chunk-3DOTGVQM.js";
import {
  getComponentPrefix,
  getPrefixCls,
  isArray,
  isUndefined,
  setGlobalConfig
} from "./chunk-XID64W4O.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createVNode,
  defineComponent,
  mergeProps,
  normalizeClass,
  normalizeStyle,
  openBlock,
  ref,
  renderList,
  resolveComponent,
  toDisplayString,
  toRef,
  toRefs,
  watch,
  withCtx,
  withModifiers
} from "./chunk-RAKT47ZN.js";

// node_modules/@arco-design/web-vue/es/slider/slider-button.js
var _sfc_main = defineComponent({
  name: "SliderButton",
  components: {
    Tooltip
  },
  inheritAttrs: false,
  props: {
    direction: {
      type: String,
      default: "horizontal"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    formatTooltip: {
      type: Function
    },
    value: [String, Number],
    tooltipPosition: {
      type: String
    },
    showTooltip: {
      type: Boolean,
      default: true
    }
  },
  emits: ["movestart", "moving", "moveend"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("slider-btn");
    const isDragging = ref(false);
    const handleMouseDown = (e) => {
      if (props.disabled) {
        return;
      }
      e.preventDefault();
      isDragging.value = true;
      on(window, "mousemove", handleMouseMove);
      on(window, "mouseup", handleMouseUp);
      on(window, "contextmenu", handleMouseUp);
      emit("movestart");
    };
    const handleMouseMove = (e) => {
      emit("moving", e.clientX, e.clientY);
    };
    const handleMouseUp = () => {
      isDragging.value = false;
      off(window, "mousemove", handleMouseMove);
      off(window, "mouseup", handleMouseUp);
      emit("moveend");
    };
    const cls = computed(() => [prefixCls]);
    const mergedTooltipPosition = computed(() => {
      var _a;
      return ((_a = props.tooltipPosition) != null ? _a : props.direction === "vertical") ? "right" : "top";
    });
    const tooltipContent = computed(() => {
      var _a, _b;
      return (_b = (_a = props.formatTooltip) == null ? void 0 : _a.call(props, props.value)) != null ? _b : `${props.value}`;
    });
    const popupVisible = computed(() => props.showTooltip ? isDragging.value ? true : void 0 : false);
    return {
      prefixCls,
      cls,
      tooltipContent,
      mergedTooltipPosition,
      popupVisible,
      handleMouseDown
    };
  }
});
var _hoisted_1 = ["aria-disabled", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_tooltip = resolveComponent("tooltip");
  return openBlock(), createBlock(_component_tooltip, {
    "popup-visible": _ctx.popupVisible,
    position: _ctx.mergedTooltipPosition,
    content: _ctx.tooltipContent
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps(_ctx.$attrs, {
        tabindex: "0",
        role: "slider",
        "aria-disabled": _ctx.disabled,
        "aria-valuemax": _ctx.max,
        "aria-valuemin": _ctx.min,
        "aria-valuenow": _ctx.value,
        "aria-valuetext": _ctx.tooltipContent,
        class: _ctx.cls,
        onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args)),
        onClick: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["stop"]))
      }), null, 16, _hoisted_1)
    ]),
    _: 1
  }, 8, ["popup-visible", "position", "content"]);
}
var SliderButton = _export_sfc(_sfc_main, [["render", _sfc_render]]);

// node_modules/@arco-design/web-vue/es/slider/utils.js
var getOffsetPercent = (value, [min, max]) => {
  const percent = Math.max((value - min) / (max - min), 0);
  return `${index_es_default.round(percent * 100, 2)}%`;
};
var getPositionStyle = (offset, direction) => {
  return direction === "vertical" ? { bottom: offset } : { left: offset };
};

// node_modules/@arco-design/web-vue/es/slider/slider-dots.js
var _sfc_main2 = defineComponent({
  name: "SliderDots",
  props: {
    data: {
      type: Array,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    direction: {
      type: String,
      default: "horizontal"
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("slider");
    const getStyle = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
    return {
      prefixCls,
      getStyle
    };
  }
});
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-dots`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: normalizeClass(`${_ctx.prefixCls}-dot-wrapper`),
        style: normalizeStyle(_ctx.getStyle(item.key))
      }, [
        createBaseVNode("div", {
          class: normalizeClass([
            `${_ctx.prefixCls}-dot`,
            { [`${_ctx.prefixCls}-dot-active`]: item.isActive }
          ])
        }, null, 2)
      ], 6);
    }), 128))
  ], 2);
}
var SliderDots = _export_sfc(_sfc_main2, [["render", _sfc_render2]]);

// node_modules/@arco-design/web-vue/es/slider/slider-marks.js
var _sfc_main3 = defineComponent({
  name: "SliderMarks",
  props: {
    data: {
      type: Array,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    direction: {
      type: String,
      default: "horizontal"
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("slider");
    const getStyle = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
    return {
      prefixCls,
      getStyle
    };
  }
});
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-marks`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        "aria-hidden": "true",
        class: normalizeClass(`${_ctx.prefixCls}-mark`),
        style: normalizeStyle(_ctx.getStyle(item.key))
      }, toDisplayString(item.content), 7);
    }), 128))
  ], 2);
}
var SliderMarks = _export_sfc(_sfc_main3, [["render", _sfc_render3]]);

// node_modules/@arco-design/web-vue/es/slider/slider-ticks.js
var _sfc_main4 = defineComponent({
  name: "SliderTicks",
  props: {
    value: {
      type: Array,
      required: true
    },
    step: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    direction: {
      type: String,
      default: "horizontal"
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("slider");
    const steps = computed(() => {
      const steps2 = [];
      const stepsLength = Math.floor((props.max - props.min) / props.step);
      for (let i = 0; i <= stepsLength; i++) {
        const stepVal = index_es_default.plus(i * props.step, props.min);
        if (stepVal <= props.min || stepVal >= props.max)
          continue;
        steps2.push({
          key: stepVal,
          isActive: stepVal >= props.value[0] && stepVal <= props.value[1]
        });
      }
      return steps2;
    });
    const getStyle = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
    return {
      prefixCls,
      steps,
      getStyle
    };
  }
});
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-ticks`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.steps, (item, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: normalizeClass([
          `${_ctx.prefixCls}-tick`,
          { [`${_ctx.prefixCls}-tick-active`]: item.isActive }
        ]),
        style: normalizeStyle(_ctx.getStyle(item.key))
      }, null, 6);
    }), 128))
  ], 2);
}
var SliderTicks = _export_sfc(_sfc_main4, [["render", _sfc_render4]]);

// node_modules/@arco-design/web-vue/es/slider/slider-input.js
var _sfc_main5 = defineComponent({
  name: "SliderInput",
  components: {
    InputNumber
  },
  props: {
    modelValue: {
      type: Array,
      required: true
    },
    min: {
      type: Number
    },
    max: {
      type: Number
    },
    step: {
      type: Number
    },
    disabled: {
      type: Boolean
    },
    range: {
      type: Boolean
    }
  },
  emits: ["startChange", "endChange"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("slider");
    return {
      prefixCls
    };
  }
});
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_input_number = resolveComponent("input-number");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-input`)
  }, [
    _ctx.range ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createVNode(_component_input_number, {
        min: _ctx.min,
        max: _ctx.max,
        step: _ctx.step,
        disabled: _ctx.disabled,
        "model-value": _ctx.modelValue[0],
        "hide-button": "",
        onChange: _cache[0] || (_cache[0] = (value) => _ctx.$emit("startChange", value))
      }, null, 8, ["min", "max", "step", "disabled", "model-value"]),
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-input-hyphens`)
      }, null, 2)
    ], 64)) : createCommentVNode("v-if", true),
    createVNode(_component_input_number, {
      min: _ctx.min,
      max: _ctx.max,
      step: _ctx.step,
      disabled: _ctx.disabled,
      "model-value": _ctx.modelValue[1],
      "hide-button": "",
      onChange: _cache[1] || (_cache[1] = (value) => _ctx.$emit("endChange", value))
    }, null, 8, ["min", "max", "step", "disabled", "model-value"])
  ], 2);
}
var SliderInput = _export_sfc(_sfc_main5, [["render", _sfc_render5]]);

// node_modules/@arco-design/web-vue/es/slider/slider.js
var _sfc_main6 = defineComponent({
  name: "Slider",
  components: {
    SliderButton,
    SliderDots,
    SliderMarks,
    SliderTicks,
    SliderInput
  },
  props: {
    modelValue: {
      type: [Number, Array],
      default: void 0
    },
    defaultValue: {
      type: [Number, Array],
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    min: {
      type: Number,
      default: 0
    },
    marks: {
      type: Object
    },
    max: {
      type: Number,
      default: 100
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    showTicks: {
      type: Boolean,
      default: false
    },
    showInput: {
      type: Boolean,
      default: false
    },
    range: {
      type: Boolean,
      default: false
    },
    formatTooltip: {
      type: Function
    },
    showTooltip: {
      type: Boolean,
      default: true
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value) => true
  },
  setup(props, { emit }) {
    const { modelValue } = toRefs(props);
    const prefixCls = getPrefixCls("slider");
    const { mergedDisabled, eventHandlers } = useFormItem({
      disabled: toRef(props, "disabled")
    });
    const trackRef = ref(null);
    const trackRect = ref();
    const defaultValue = props.modelValue ? props.modelValue : props.defaultValue;
    const startValue = ref(isArray(defaultValue) ? defaultValue[0] : 0);
    const endValue = ref(isArray(defaultValue) ? defaultValue[1] : defaultValue);
    watch(modelValue, (value) => {
      var _a, _b, _c, _d, _e;
      if (isArray(value)) {
        startValue.value = (_b = (_a = value[0]) != null ? _a : props.min) != null ? _b : 0;
        endValue.value = (_d = (_c = value[1]) != null ? _c : props.min) != null ? _d : 0;
      } else {
        endValue.value = (_e = value != null ? value : props.min) != null ? _e : 0;
      }
    });
    const handleChange = () => {
      var _a, _b;
      if (props.range) {
        emit("update:modelValue", [startValue.value, endValue.value]);
        emit("change", [startValue.value, endValue.value]);
      } else {
        emit("update:modelValue", endValue.value);
        emit("change", endValue.value);
      }
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
    };
    const handleStartChange = (value) => {
      value = value != null ? value : props.min;
      startValue.value = value;
      handleChange();
    };
    const handleEndChange = (value) => {
      value = value != null ? value : props.min;
      endValue.value = value;
      handleChange();
    };
    const computedValue = computed(() => {
      var _a, _b, _c;
      if (props.range) {
        if (isArray(props.modelValue)) {
          return props.modelValue;
        }
        return [startValue.value, (_a = props.modelValue) != null ? _a : endValue.value];
      }
      if (isUndefined(props.modelValue)) {
        return [startValue.value, endValue.value];
      }
      if (isArray(props.modelValue)) {
        return [(_b = props.min) != null ? _b : 0, props.modelValue[1]];
      }
      return [(_c = props.min) != null ? _c : 0, props.modelValue];
    });
    const markList = computed(() => Object.keys(props.marks || {}).map((index) => {
      var _a;
      const key = Number(index);
      return {
        key,
        content: (_a = props.marks) == null ? void 0 : _a[key],
        isActive: key >= computedValue.value[0] && key <= computedValue.value[1]
      };
    }));
    const getBtnStyle = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
    const isDragging = ref(false);
    const handleMoveStart = () => {
      isDragging.value = true;
      if (trackRef.value) {
        trackRect.value = trackRef.value.getBoundingClientRect();
      }
    };
    function getValueByCoords(x, y) {
      if (!trackRect.value) {
        return 0;
      }
      const { left, top, width, height } = trackRect.value;
      const trackLength = props.direction === "horizontal" ? width : height;
      const stepLength = trackLength * props.step / (props.max - props.min);
      let diff = props.direction === "horizontal" ? x - left : top + height - y;
      if (diff < 0)
        diff = 0;
      if (diff > trackLength)
        diff = trackLength;
      const steps = Math.round(diff / stepLength);
      return index_es_default.plus(props.min, index_es_default.times(steps, props.step));
    }
    const handleEndMoving = (x, y) => {
      endValue.value = getValueByCoords(x, y);
      handleChange();
    };
    const handleClick = (e) => {
      if (mergedDisabled.value) {
        return;
      }
      const { clientX, clientY } = e;
      if (trackRef.value) {
        trackRect.value = trackRef.value.getBoundingClientRect();
      }
      endValue.value = getValueByCoords(clientX, clientY);
      handleChange();
    };
    function getBarStyle([start, end]) {
      if (start > end) {
        [start, end] = [end, start];
      }
      return props.direction === "vertical" ? {
        bottom: getOffsetPercent(start, [props.min, props.max]),
        top: getOffsetPercent(props.max + props.min - end, [
          props.min,
          props.max
        ])
      } : {
        left: getOffsetPercent(start, [props.min, props.max]),
        right: getOffsetPercent(props.max + props.min - end, [
          props.min,
          props.max
        ])
      };
    }
    const handleStartMoving = (x, y) => {
      startValue.value = getValueByCoords(x, y);
      handleChange();
    };
    const handleMoveEnd = () => {
      isDragging.value = false;
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-vertical`]: props.direction === "vertical",
        [`${prefixCls}-with-marks`]: Boolean(props.marks)
      }
    ]);
    const trackCls = computed(() => [
      `${prefixCls}-track`,
      {
        [`${prefixCls}-track-disabled`]: mergedDisabled.value,
        [`${prefixCls}-track-vertical`]: props.direction === "vertical"
      }
    ]);
    return {
      prefixCls,
      cls,
      trackCls,
      trackRef,
      computedValue,
      mergedDisabled,
      markList,
      getBtnStyle,
      getBarStyle,
      handleClick,
      handleMoveStart,
      handleEndMoving,
      handleMoveEnd,
      handleStartMoving,
      handleStartChange,
      handleEndChange
    };
  }
});
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_slider_ticks = resolveComponent("slider-ticks");
  const _component_slider_dots = resolveComponent("slider-dots");
  const _component_slider_marks = resolveComponent("slider-marks");
  const _component_slider_button = resolveComponent("slider-button");
  const _component_slider_input = resolveComponent("slider-input");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    createBaseVNode("div", {
      ref: "trackRef",
      class: normalizeClass(_ctx.trackCls),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-bar`),
        style: normalizeStyle(_ctx.getBarStyle(_ctx.computedValue))
      }, null, 6),
      _ctx.showTicks ? (openBlock(), createBlock(_component_slider_ticks, {
        key: 0,
        value: _ctx.computedValue,
        step: _ctx.step,
        min: _ctx.min,
        max: _ctx.max,
        direction: _ctx.direction
      }, null, 8, ["value", "step", "min", "max", "direction"])) : createCommentVNode("v-if", true),
      _ctx.marks ? (openBlock(), createBlock(_component_slider_dots, {
        key: 1,
        data: _ctx.markList,
        min: _ctx.min,
        max: _ctx.max,
        direction: _ctx.direction
      }, null, 8, ["data", "min", "max", "direction"])) : createCommentVNode("v-if", true),
      _ctx.marks ? (openBlock(), createBlock(_component_slider_marks, {
        key: 2,
        data: _ctx.markList,
        min: _ctx.min,
        max: _ctx.max,
        direction: _ctx.direction
      }, null, 8, ["data", "min", "max", "direction"])) : createCommentVNode("v-if", true),
      _ctx.range ? (openBlock(), createBlock(_component_slider_button, {
        key: 3,
        style: normalizeStyle(_ctx.getBtnStyle(_ctx.computedValue[0])),
        value: _ctx.computedValue[0],
        direction: _ctx.direction,
        disabled: _ctx.mergedDisabled,
        min: _ctx.min,
        max: _ctx.max,
        "format-tooltip": _ctx.formatTooltip,
        "show-tooltip": _ctx.showTooltip,
        onMovestart: _ctx.handleMoveStart,
        onMoving: _ctx.handleStartMoving,
        onMoveend: _ctx.handleMoveEnd
      }, null, 8, ["style", "value", "direction", "disabled", "min", "max", "format-tooltip", "show-tooltip", "onMovestart", "onMoving", "onMoveend"])) : createCommentVNode("v-if", true),
      createVNode(_component_slider_button, {
        style: normalizeStyle(_ctx.getBtnStyle(_ctx.computedValue[1])),
        value: _ctx.computedValue[1],
        direction: _ctx.direction,
        disabled: _ctx.mergedDisabled,
        min: _ctx.min,
        max: _ctx.max,
        "format-tooltip": _ctx.formatTooltip,
        "show-tooltip": _ctx.showTooltip,
        onMovestart: _ctx.handleMoveStart,
        onMoving: _ctx.handleEndMoving,
        onMoveend: _ctx.handleMoveEnd
      }, null, 8, ["style", "value", "direction", "disabled", "min", "max", "format-tooltip", "show-tooltip", "onMovestart", "onMoving", "onMoveend"])
    ], 2),
    _ctx.showInput ? (openBlock(), createBlock(_component_slider_input, {
      key: 0,
      "model-value": _ctx.computedValue,
      min: _ctx.min,
      max: _ctx.max,
      step: _ctx.step,
      range: _ctx.range,
      disabled: _ctx.disabled,
      onStartChange: _ctx.handleStartChange,
      onEndChange: _ctx.handleEndChange
    }, null, 8, ["model-value", "min", "max", "step", "range", "disabled", "onStartChange", "onEndChange"])) : createCommentVNode("v-if", true)
  ], 2);
}
var _Slider = _export_sfc(_sfc_main6, [["render", _sfc_render6]]);

// node_modules/@arco-design/web-vue/es/slider/index.js
var Slider = Object.assign(_Slider, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Slider.name, _Slider);
  }
});

export {
  Slider
};
//# sourceMappingURL=chunk-4OF6MNNE.js.map
