import {
  useIndex
} from "./chunk-5KRPJHEC.js";
import {
  IconImageClose
} from "./chunk-MRE7FA5I.js";
import {
  ResizeObserver,
  Trigger
} from "./chunk-NBVKDR52.js";
import {
  getAllElements
} from "./chunk-HVIY2XKT.js";
import {
  IconLoading
} from "./chunk-7EITU4YN.js";
import {
  _export_sfc
} from "./chunk-3DOTGVQM.js";
import {
  getComponentPrefix,
  getPrefixCls,
  isNumber,
  setGlobalConfig
} from "./chunk-XID64W4O.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  defineComponent,
  inject,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onMounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderSlot,
  resolveComponent,
  toDisplayString,
  toRefs,
  watch,
  withCtx
} from "./chunk-RAKT47ZN.js";

// node_modules/@arco-design/web-vue/es/avatar/context.js
var avatarGroupInjectionKey = Symbol("ArcoAvatarGroup");

// node_modules/@arco-design/web-vue/es/avatar/avatar.js
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main = defineComponent({
  name: "Avatar",
  components: {
    ResizeObserver,
    IconImageClose,
    IconLoading
  },
  props: {
    shape: {
      type: String,
      default: "circle"
    },
    imageUrl: String,
    size: Number,
    autoFixFontSize: {
      type: Boolean,
      default: true
    },
    triggerType: {
      type: String,
      default: "button"
    },
    triggerIconStyle: {
      type: Object
    },
    objectFit: {
      type: String
    }
  },
  emits: {
    click: (ev) => true,
    error: () => true,
    load: () => true
  },
  setup(props, { slots, emit, attrs }) {
    const { shape, size, autoFixFontSize, triggerType, triggerIconStyle } = toRefs(props);
    const prefixCls = getPrefixCls("avatar");
    const groupCtx = inject(avatarGroupInjectionKey, void 0);
    const itemRef = ref();
    const wrapperRef = ref();
    const mergedShape = computed(() => {
      var _a;
      return (_a = groupCtx == null ? void 0 : groupCtx.shape) != null ? _a : shape.value;
    });
    const mergedSize = computed(() => {
      var _a;
      return (_a = groupCtx == null ? void 0 : groupCtx.size) != null ? _a : size.value;
    });
    const mergedAutoFixFontSize = computed(() => {
      var _a;
      return (_a = groupCtx == null ? void 0 : groupCtx.autoFixFontSize) != null ? _a : autoFixFontSize.value;
    });
    const isImage = ref(false);
    const hasError = ref(false);
    const shouldLoad = ref(true);
    const isLoaded = ref(false);
    const index = groupCtx ? useIndex({
      itemRef,
      selector: `.${prefixCls}`
    }).computedIndex : ref(-1);
    const outerStyle = computed(() => {
      var _a;
      const style = isNumber(mergedSize.value) ? {
        width: `${mergedSize.value}px`,
        height: `${mergedSize.value}px`,
        fontSize: `${mergedSize.value / 2}px`
      } : {};
      if (groupCtx) {
        style.zIndex = groupCtx.zIndexAscend ? index.value + 1 : groupCtx.total - index.value;
        style.marginLeft = index.value !== 0 ? `-${((_a = mergedSize.value) != null ? _a : 40) / 4}px` : "0";
      }
      return style;
    });
    const computedTriggerIconStyle = useTriggerIconStyle({
      triggerIconStyle: triggerIconStyle == null ? void 0 : triggerIconStyle.value,
      inlineStyle: attrs.style,
      triggerType: triggerType.value
    });
    const autoFixFontSizeHandler = () => {
      if (!isImage.value && !props.imageUrl) {
        nextTick(() => {
          var _a;
          if (!wrapperRef.value || !itemRef.value) {
            return;
          }
          const textWidth = wrapperRef.value.clientWidth;
          const avatarWidth = (_a = mergedSize.value) != null ? _a : itemRef.value.offsetWidth;
          const scale = avatarWidth / (textWidth + 8);
          if (avatarWidth && scale < 1) {
            wrapperRef.value.style.transform = `scale(${scale}) translateX(-50%)`;
          }
          shouldLoad.value = true;
        });
      }
    };
    onMounted(() => {
      var _a;
      if (((_a = wrapperRef.value) == null ? void 0 : _a.firstElementChild) && ["IMG", "PICTURE"].includes(wrapperRef.value.firstElementChild.tagName)) {
        isImage.value = true;
      }
      if (mergedAutoFixFontSize.value) {
        autoFixFontSizeHandler();
      }
    });
    watch(size, () => {
      if (mergedAutoFixFontSize.value) {
        autoFixFontSizeHandler();
      }
    });
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-${mergedShape.value}`
    ]);
    const wrapperCls = computed(() => isImage.value || props.imageUrl ? `${prefixCls}-image` : `${prefixCls}-text`);
    const onClick = (e) => {
      emit("click", e);
    };
    const handleResize = () => {
      if (mergedAutoFixFontSize.value) {
        autoFixFontSizeHandler();
      }
    };
    const handleImgLoad = () => {
      isLoaded.value = true;
      emit("load");
    };
    const handleImgError = () => {
      hasError.value = true;
      emit("error");
    };
    return {
      prefixCls,
      itemRef,
      cls,
      outerStyle,
      wrapperRef,
      wrapperCls,
      computedTriggerIconStyle,
      isImage,
      shouldLoad,
      isLoaded,
      hasError,
      onClick,
      handleResize,
      handleImgLoad,
      handleImgError
    };
  }
});
var useTriggerIconStyle = ({
  triggerType,
  inlineStyle = {},
  triggerIconStyle = {}
}) => {
  let addon = {};
  if (triggerType === "button" && (!triggerIconStyle || triggerIconStyle && !triggerIconStyle.color) && inlineStyle && inlineStyle.backgroundColor) {
    addon = { color: inlineStyle.backgroundColor };
  }
  return __spreadValues(__spreadValues({}, triggerIconStyle), addon);
};
var _hoisted_1 = ["src"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconImageClose = resolveComponent("IconImageClose");
  const _component_IconLoading = resolveComponent("IconLoading");
  const _component_resize_observer = resolveComponent("resize-observer");
  return openBlock(), createElementBlock("div", {
    ref: "itemRef",
    style: normalizeStyle(_ctx.outerStyle),
    class: normalizeClass([
      _ctx.cls,
      {
        [`${_ctx.prefixCls}-with-trigger-icon`]: Boolean(_ctx.$slots["trigger-icon"])
      }
    ]),
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, [
    createVNode(_component_resize_observer, { onResize: _ctx.handleResize }, {
      default: withCtx(() => [
        createBaseVNode("span", {
          ref: "wrapperRef",
          class: normalizeClass(_ctx.wrapperCls)
        }, [
          _ctx.imageUrl ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _ctx.hasError ? renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
              createBaseVNode("div", {
                class: normalizeClass(`${_ctx.prefixCls}-image-icon`)
              }, [
                createVNode(_component_IconImageClose)
              ], 2)
            ]) : createCommentVNode("v-if", true),
            !(_ctx.hasError || !_ctx.shouldLoad) && !_ctx.isLoaded ? renderSlot(_ctx.$slots, "default", { key: 1 }, () => [
              createBaseVNode("div", {
                class: normalizeClass(`${_ctx.prefixCls}-image-icon`)
              }, [
                createVNode(_component_IconLoading)
              ], 2)
            ]) : createCommentVNode("v-if", true),
            !(_ctx.hasError || !_ctx.shouldLoad) ? (openBlock(), createElementBlock("img", {
              key: 2,
              src: _ctx.imageUrl,
              style: normalizeStyle({
                width: _ctx.size + "px",
                height: _ctx.size + "px",
                objectFit: _ctx.objectFit
              }),
              alt: "avatar",
              onLoad: _cache[0] || (_cache[0] = (...args) => _ctx.handleImgLoad && _ctx.handleImgLoad(...args)),
              onError: _cache[1] || (_cache[1] = (...args) => _ctx.handleImgError && _ctx.handleImgError(...args))
            }, null, 44, _hoisted_1)) : createCommentVNode("v-if", true)
          ], 64)) : renderSlot(_ctx.$slots, "default", { key: 1 })
        ], 2)
      ]),
      _: 3
    }, 8, ["onResize"]),
    _ctx.$slots["trigger-icon"] ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-trigger-icon-${_ctx.triggerType}`),
      style: normalizeStyle(_ctx.computedTriggerIconStyle)
    }, [
      renderSlot(_ctx.$slots, "trigger-icon")
    ], 6)) : createCommentVNode("v-if", true)
  ], 6);
}
var _Avatar = _export_sfc(_sfc_main, [["render", _sfc_render]]);

// node_modules/@arco-design/web-vue/es/popover/popover.js
var _sfc_main2 = defineComponent({
  name: "Popover",
  components: {
    Trigger
  },
  props: {
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    title: String,
    content: String,
    trigger: {
      type: [String, Array],
      default: "hover"
    },
    position: {
      type: String,
      default: "top"
    },
    contentClass: {
      type: [String, Array, Object]
    },
    contentStyle: {
      type: Object
    },
    arrowClass: {
      type: [String, Array, Object]
    },
    arrowStyle: {
      type: Object
    },
    popupContainer: {
      type: [String, Object]
    }
  },
  emits: {
    "update:popupVisible": (visible) => true,
    "popupVisibleChange": (visible) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("popover");
    const _popupVisible = ref(props.defaultPopupVisible);
    const computedPopupVisible = computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
    });
    const handlePopupVisibleChange = (visible) => {
      _popupVisible.value = visible;
      emit("update:popupVisible", visible);
      emit("popupVisibleChange", visible);
    };
    const contentCls = computed(() => [
      `${prefixCls}-popup-content`,
      props.contentClass
    ]);
    const arrowCls = computed(() => [
      `${prefixCls}-popup-arrow`,
      props.arrowClass
    ]);
    return {
      prefixCls,
      computedPopupVisible,
      contentCls,
      arrowCls,
      handlePopupVisibleChange
    };
  }
});
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_trigger = resolveComponent("trigger");
  return openBlock(), createBlock(_component_trigger, {
    class: normalizeClass(_ctx.prefixCls),
    trigger: _ctx.trigger,
    position: _ctx.position,
    "popup-visible": _ctx.computedPopupVisible,
    "popup-offset": 10,
    "content-class": _ctx.contentCls,
    "content-style": _ctx.contentStyle,
    "arrow-class": _ctx.arrowCls,
    "arrow-style": _ctx.arrowStyle,
    "show-arrow": "",
    "popup-container": _ctx.popupContainer,
    "animation-name": "zoom-in-fade-out",
    "auto-fit-transform-origin": "",
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }, {
    content: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ])
      ], 2),
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        renderSlot(_ctx.$slots, "content", {}, () => [
          createTextVNode(toDisplayString(_ctx.content), 1)
        ])
      ], 2)
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["class", "trigger", "position", "popup-visible", "content-class", "content-style", "arrow-class", "arrow-style", "popup-container", "onPopupVisibleChange"]);
}
var _Popover = _export_sfc(_sfc_main2, [["render", _sfc_render2]]);

// node_modules/@arco-design/web-vue/es/popover/index.js
var Popover = Object.assign(_Popover, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Popover.name, _Popover);
  }
});

// node_modules/@arco-design/web-vue/es/avatar/avatar-group.js
var AvatarGroup = defineComponent({
  name: "AvatarGroup",
  props: {
    shape: {
      type: String,
      default: "circle"
    },
    size: Number,
    autoFixFontSize: {
      type: Boolean,
      default: true
    },
    maxCount: {
      type: Number,
      default: 0
    },
    zIndexAscend: {
      type: Boolean,
      default: false
    },
    maxStyle: {
      type: Object
    },
    maxPopoverTriggerProps: {
      type: Object
    }
  },
  setup(props, {
    slots
  }) {
    const {
      shape,
      size,
      autoFixFontSize,
      zIndexAscend
    } = toRefs(props);
    const prefixCls = getPrefixCls("avatar-group");
    const total = ref(0);
    provide(avatarGroupInjectionKey, reactive({
      shape,
      size,
      autoFixFontSize,
      zIndexAscend,
      total
    }));
    return () => {
      var _a, _b;
      const children = getAllElements((_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : []);
      const avatarsToRender = props.maxCount > 0 ? children.slice(0, props.maxCount) : children;
      const avatarsInPopover = props.maxCount > 0 ? children.slice(props.maxCount) : [];
      if (total.value !== children.length) {
        total.value = children.length;
      }
      return createVNode("div", {
        "class": prefixCls
      }, [avatarsToRender, avatarsInPopover.length > 0 && createVNode(Popover, props.maxPopoverTriggerProps, {
        default: () => [createVNode(_Avatar, {
          "class": `${prefixCls}-max-count-avatar`,
          "style": props.maxStyle
        }, {
          default: () => [createTextVNode("+"), avatarsInPopover.length]
        })],
        content: () => createVNode("div", null, [avatarsInPopover])
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/avatar/index.js
var Avatar = Object.assign(_Avatar, {
  Group: AvatarGroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Avatar.name, _Avatar);
    app.component(componentPrefix + AvatarGroup.name, AvatarGroup);
  }
});

export {
  Popover,
  AvatarGroup,
  Avatar
};
//# sourceMappingURL=chunk-CZG3MAQC.js.map
